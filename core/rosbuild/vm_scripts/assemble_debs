#!/usr/bin/env python
# copyright 2009 morgan quigley, bsd license blah blah
# much work lifted from scott hassan's rosdeb package
# this script will build debs from whatever is in /opt/ros

import os, shutil, yaml, urllib2, subprocess, sys

def debianize_name(name):
  return name.replace('_','-')

def build_deb(path):
  stack_name = path.split('/')[-1]
  if not os.path.exists(path) or not stack_name in released:
    return # get that out
  version = stacks[stack_name][distro_name]
  deb_dir = os.path.join(workspace, stack_name)
  print "working on %s version %s" % (stack_name, version)
  print "  copying files..."
  base_path = os.path.join(deb_dir, 'opt', 'ros', distro_name)
  if stack_name == 'ros':
    landing_dir = os.path.join(base_path, 'ros')
  else:
    landing_dir = os.path.join(base_path, 'stacks', stack_name)
  shutil.copytree(path, landing_dir, symlinks=True)
  print "  removing non-essential files..."
  #subprocess.check_call(['find',deb_dir,'-name','.svn',+'.deb'])
  non_essential = subprocess.Popen(['find',deb_dir,'-name','.svn'], env=env_vars, stdout=subprocess.PIPE).communicate()[0].split()
  non_essential += subprocess.Popen(['find',deb_dir,'-name','*.o'], env=env_vars, stdout=subprocess.PIPE).communicate()[0].split()
  non_essential += subprocess.Popen(['find',deb_dir,'-name','.deps'], env=env_vars, stdout=subprocess.PIPE).communicate()[0].split()
  non_essential += subprocess.Popen(['find',deb_dir,'-name','CMakeFiles'], env=env_vars, stdout=subprocess.PIPE).communicate()[0].split()
  non_essential += subprocess.Popen(['find',deb_dir,'-name','CMakeCache.txt'], env=env_vars, stdout=subprocess.PIPE).communicate()[0].split()
  subprocess.check_call(['sudo','rm','-rf'] + non_essential)
  print "  generating dpkg dependencies..."
  rosstack_path = os.path.join(ros_root, 'bin', 'rosstack')
  stack_deps = subprocess.Popen([rosstack_path,'deps',stack_name], env=env_vars, stdout=subprocess.PIPE).communicate()[0].split()
  deb_deps = ['libc6','build-essential','cmake','python-yaml','subversion']
  # get the packages in this stack
  pkgs = subprocess.Popen([rosstack_path,'contents',stack_name], env=env_vars, stdout=subprocess.PIPE).communicate()[0].split()
  # snarf the output of 'rosdep generate_bash' for those packages
  bash = subprocess.Popen([os.path.join(ros_root,'bin','rosdep'),'generate_bash']+pkgs, env=env_vars, stdout=subprocess.PIPE).communicate()[0].split('\n')
  install_line = [s for s in bash if s.startswith("sudo apt-get install")]
  native_packages = []
  if install_line:
    native_packages = install_line[0][20:].split()
  deb_deps += native_packages
  deb_deps += [debianize_name("ros-%s-%s"%(distro_name,s)) for s in stack_deps] 
  deb_name = debianize_name("ros-%s-%s" % (distro_name, stack_name))
  arch = subprocess.Popen(['dpkg', '--print-architecture'], env=env_vars, stdout=subprocess.PIPE).communicate()[0].strip()
  size = int(subprocess.Popen(["du","-bs",deb_dir], stdout=subprocess.PIPE).communicate()[0].strip().split()[0])
  os.mkdir(os.path.join(deb_dir, 'DEBIAN'), 0755)
  control = open(os.path.join(deb_dir, 'DEBIAN', "control"), "w")
  control.write("Package: %s\n" % deb_name)
  control.write("Source: %s\n" % deb_name)
  control.write("Version: %s-1\n" % version)
  control.write("Architecture: %s\n" % arch)
  # not sure what to put here. lintian says it needs an email address.
  control.write("Maintainer: The ROS community <mquigley@cs.stanford.edu>\n")
  control.write("Installed-Size: %s\n" % size)
  control.write("Depends: %s\n" % ", ".join(deb_deps))
  control.write("Section: devel\n")
  control.write("Priority: optional\n")
  control.write("Homepage: http://ros.org\n")
  control.write("Description: ROS - a Robot Operating System\n")
  control.write(" More documentation could go here\n")
  print "  running dpkg-deb..."
  os.chdir(workspace)
  control.close()
  subprocess.check_call(['fakeroot','dpkg-deb','--build',deb_dir,deb_name+'_'+version+'_jaunty_'+arch+'.deb'])

ros_root = '/opt/ros/ros'
stacks_root = '/opt/ros/stacks'
if 'PATH' in os.environ:
  bin_path = ':'.join([os.path.join(ros_root, 'bin'), os.environ['PATH']])
else:
  bin_path = os.path.join(ros_root, 'bin')
if 'PYTHONPATH' in os.environ:
  pythonpath = ':'.join([os.environ['PYTHONPATH'], os.path.join(ros_root, 'core', 'roslib', 'src')])
else:
  pythonpath = os.path.join(ros_root, 'core', 'roslib', 'src')
env_vars = os.environ.copy()
env_vars.update({'ROS_ROOT' : ros_root,
                 'PATH' : bin_path,
                 'PYTHONPATH' : pythonpath,
                 'ROS_MASTER_URI' : 'http://localhost:11311',
                 'ROS_PACKAGE_PATH' : stacks_root,
                 'ROSDEP_REINSTALL' : '1',
                 'ROBOT' : 'sim'})

workspace = os.path.join(os.getcwd(), 'deb_workspace') 
distro_name = 'latest'
f = urllib2.urlopen('http://ros.org/rosdistro.yaml')
d = yaml.load(f)
distros = d['distros']
stacks = d['stacks']
for distro in distros:
  if distro_name in distro:
    released = distro[distro_name]

try:
  os.mkdir(workspace, 0755)
except:
  raise Exception("could not create workspace directory, ahhhhhh")
 
# first, build deb for the ros stack, in /opt/ros/ros
build_deb(ros_root)
# now, build debs for stacks in /opt/ros/stacks/BLAH
for stack in os.listdir(stacks_root): 
  if stack != '.svn':
    build_deb(os.path.join(stacks_root, stack))
