#!/usr/bin/env python

import os
import sys

NAME='rosh'

#if sys.stdin.isatty()

def rosh_main(args=None):
    if args is None:
        args=sys.argv
    args = args[1:]
    import optparse
    parser = optparse.OptionParser(usage="usage: %prog pkg/Type [plugins...]", prog=NAME)
    options, args = parser.parse_args(args)

    names = [n for n in args if n.startswith('__name:=')]
    if names:
        if len(names) != 1:
            parser.error("You may only specify one roshlet name")
        name = names[0]
    else:
        name = 'roshlet'

    # just-in-time load deps
    import roslib
    roslib.load_manifest('rosh')
    import rospy
    # - filter out remapping args
    args = rospy.myargv(args)
    if len(args) < 1:
        parser.error("Please specify roshlet pkg/Type")

    # resolve args[0] as either a filename or a pkg/Type
    import rosh.impl.roshlets
    arg = args[0]
    if os.path.isfile(arg):
        script = arg
    else:
        if '/' not in args[0]:
            parser.error("Please specify roshlet pkg/Type, e.g. rosh/echolet.py")
        try:
            package, type_ = arg.split('/')
        except:
            parser.error("Invalid roshlet pkg/Type: %s"%(args[0]))

        script = rosh.impl.roshlets.find_roshlet(package, type_)

    # run the rosh script
    plugins = args[1:]
    try:
        rosh.impl.roshlets.standalone(name, script, plugins)
    except KeyboardInterrupt:
        # squelch ctrl-c exits
        pass

# emulate the behavior of Python: drop into interpreter if no args,
# load script otherwise
if len(sys.argv) > 1:
    rosh_main(sys.argv)
else:
    # Load the ipython shell in interactive mode. This is a bit ugly
    # b/c we have to hack sys.argv in this route, but the IPShellEmbed
    # didn't behave how I wanted it to.
    import roslib.packages
    p = os.path.join(roslib.packages.get_pkg_dir('rosh'), 'shell.py')
    import IPython.Shell
    argv = '-i '+p
    sys.argv = [sys.argv[0]] + ['-i', p] 
    IPython.Shell.start().mainloop()
